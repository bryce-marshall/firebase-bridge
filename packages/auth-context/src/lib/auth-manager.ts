import { DecodedAppCheckToken } from 'firebase-admin/app-check';
import {
  DEFAULT_PROJECT_ID,
  DEFAULT_REGION,
  EPOCH_MINUTES_30,
  EPOCH_MINUTES_60,
} from './_internal/constants.js';
import { providerId } from './_internal/provider-id.js';
import {
  appId,
  cloneDeep,
  epochSeconds,
  hexId,
  millisToSeconds,
  projectNumber,
  userId,
} from './_internal/util.js';
import { formatIss } from './http/_internal/util.js';
import { HttpsBroker } from './https/https-broker.js';
import {
  AppCheckConstructor,
  AppCheckData,
  AuthContextOptions,
  AuthKey,
  AuthProvider,
  FirebaseIdentities,
  GenericAuthContext,
  IdentityConstructor,
  MockIdentity,
  RequestContext,
  RequestContextOptions,
} from './types.js';

/**
 * Construction options for {@link AuthManager}.
 *
 * @remarks
 * - All values are optional; reasonable defaults are derived when omitted.
 * - `now` allows deterministic time control in tests.
 */
export interface AuthManagerOptions {
  /**
   * Function that returns the current epoch milliseconds.
   * Used to derive `iat`, `auth_time`, and `exp` when not explicitly provided.
   * Defaults to `() => Date.now()`.
   */
  now?: () => number;

  /**
   * Firebase App ID used to populate App Check tokens (`sub`, `app_id`).
   * Defaults to a synthetic value derived from {@link projectNumber}.
   */
  appId?: string;

  /**
   * Firebase **project number** used as part of the App Check audience.
   * Defaults to a synthetic value from {@link projectNumber}.
   */
  projectNumber?: string;

  /**
   * Firebase **project ID** (human-readable). Used as the App Check audience.
   * Defaults to `'default-project'`.
   */
  projectId?: string;

  /**
   * Default Cloud Functions region used by the HTTPS broker.
   * Defaults to `'nam5'`.
   */
  region?: string;
  /**
   * Allows specification of consistent oauth ids for providers where tests require them.
   * Where a provider is specified without an accompanying id, the id will be generated by
   * the `AuthManager` and will remain consistent throughout its lifecycle.
   * Example:
   * ```ts
   *    oauthIds: {
   *       'google.com': '24I2SUdn5m4ox716tbiH6MML7jv6',
   *       'apple.com': undefined,
   *    }
   */
  oauthIds?: Record<string, string | undefined>;
}

/**
 * Test-focused provider for mock authentication and App Check contexts for Firebase HTTPS functions.
 *
 * @typeParam TKey - The key type used to register and retrieve identities (defaults to {@link AuthKey}).
 *
 * @remarks
 * - Maintains a registry of immutable **identity templates** keyed by `TKey`.
 * - Produces per-call **auth contexts** with fresh time claims (`iat`, `auth_time`, `exp`)
 *   and an optional App Check token (enabled by default).
 * - All returned identity/context objects are deep-cloned to prevent mutation of the registry.
 */
export class AuthManager<TKey extends AuthKey = AuthKey>
  implements AuthProvider<TKey>
{
  private _ids = new Map<TKey, MockIdentity>();
  private _now: () => number;

  /**
   * A set of consistent oauth ids for providers where tests require them, defined during
   * construction. This collection is readonly (frozen).
   */
  readonly oauthIds: Record<string, string>;

  /**
   * Firebase App ID used for App Check tokens (`sub`, `app_id`).
   */
  readonly appId: string;

  /**
   * Firebase project **number** used in App Check token audience.
   */
  readonly projectNumber: string;

  /**
   * The audience for which App Check tokens are intended. Equal to your Firebase **project ID**.
   */
  readonly projectId: string;

  /**
   * Default Cloud Functions region used by {@link https}.
   */
  readonly region: string;

  /**
   * Issuer string used for App Check tokens, derived from the {@link projectNumber}.
   */
  readonly iss: string;

  /**
   * The HTTPS broker bound to this manager’s defaults (project/region).
   *
   * @remarks
   * The broker is used to invoke mock HTTPS callable/HTTP handlers with synthesized auth/app contexts.
   */
  readonly https: HttpsBroker<TKey>;

  /**
   * Create a new {@link AuthManager}.
   *
   * @param options - Optional initialization overrides. See {@link AuthManagerOptions}.
   */
  constructor(options?: AuthManagerOptions) {
    this._now = options?.now ?? (() => Date.now());
    this.projectNumber = options?.projectNumber ?? projectNumber();
    this.appId = options?.appId ?? appId(this.projectNumber);
    this.projectId = options?.projectId ?? DEFAULT_PROJECT_ID;
    this.region = options?.region ?? DEFAULT_REGION;
    this.iss = formatIss(this.projectNumber);
    this.https = new HttpsBroker(this);
    this.oauthIds = {};
    if (options?.oauthIds) {
      for (const [key, value] of Object.entries(options.oauthIds)) {
        this.oauthIds[key] = value?.trim() ? value : providerId(key);
      }
    }
    Object.freeze(this.oauthIds);
  }

  /**
   * Register an identity template for a key.
   *
   * @param key - Registry key.
   * @param identity - A lightweight identity **constructor** (template). It is normalized and stored immutably.
   * @returns - the uid of the newly created identity.
   * @throws {Error} If the key is already registered.
   *
   * @remarks
   * - The provided `identity` is normalized via {@link staticIdentity}, then deep-cloned when read.
   * - Subsequent modifications to the original `identity` object do **not** affect the registry.
   */
  register(key: TKey, identity?: IdentityConstructor): string {
    if (this._ids.has(key))
      throw new Error(`Identity already registered for the key "${key}".`);

    const result = this.staticIdentity(identity ?? {});
    this._ids.set(key, result);

    return result.uid;
  }

  /**
   * Remove a registered identity.
   *
   * @param key - Registry key.
   * @returns `true` if the entry existed and was removed; otherwise `false`.
   */
  deregister(key: TKey): boolean {
    return this._ids.delete(key);
  }

  /**
   * Retrieve a deep-cloned identity template for a key.
   *
   * @param key - Registry key.
   * @returns The identity if registered, otherwise `undefined`.
   *
   * @remarks
   * The clone prevents accidental mutations from affecting the stored template.
   */
  identity(key: TKey): MockIdentity | undefined {
    return cloneDeep(this._ids.get(key));
  }

  requestContext(options?: RequestContextOptions): RequestContext {
    const context: RequestContext = {
      projectId: this.projectId,
    };
    if (options?.appCheck !== false) {
      context.app = this.appCheck(
        options?.appCheck === true ? undefined : options?.appCheck
      );
    }

    return context;
  }

  /**
   * Build a **GenericAuthContext** for a registered key.
   *
   * @param key - Registry key.
   * @param options - Context overrides (timestamps, App Check, etc.). See {@link AuthContextOptions}.
   * @returns A new {@link GenericAuthContext} with fresh time claims and (by default) an App Check token.
   * @throws {Error} If no identity is registered for the given key.
   *
   * @remarks
   * - Default timing:
   *   - `iat` defaults to `now()`.
   *   - `auth_time` defaults to `iat - 30m`.
   *   - `exp` defaults to `iat + 30m`.
   * - Set `suppressAppCheck: true` to omit the `app` field.
   * - All returned structures are deep-cloned and safe to mutate in tests.
   */
  authContext(key: TKey, options?: AuthContextOptions): GenericAuthContext {
    const id = this._ids.get(key);
    if (id == undefined)
      throw new Error(`No identity registered for the key "${key}".`);

    const iat = epochSeconds(options?.iat) ?? millisToSeconds(this._now());
    const auth_time = epochSeconds(options?.authTime) ?? iat - EPOCH_MINUTES_30;
    const exp = epochSeconds(options?.expires) ?? iat + EPOCH_MINUTES_30;
    const identity: MockIdentity = cloneDeep(id);

    const context: GenericAuthContext = {
      ...this.requestContext(options),
      auth_time,
      exp,
      iat,
      identity,
    };

    return context;
  }

  /**
   * Synthesize an App Check payload from optional constructor values.
   *
   * @param c - Optional constructor to seed arbitrary custom claims. Any provided `iat`/`exp` are respected;
   *            missing values are defaulted to a one-hour window (`exp = now + 60m`, `iat = exp - 60m`).
   * @returns A normalized {@link AppCheckData} containing the `appId` and a {@link DecodedAppCheckToken}.
   *
   * @remarks
   * Populates/overrides the following claims:
   * - `sub` and `app_id` → {@link appId}
   * - `aud` → `[projectNumber, projectId]`
   * - `iss` → {@link iss}
   * - `iat`/`exp` → derived from `c` or defaults
   */
  appCheck(c?: AppCheckConstructor | undefined): AppCheckData {
    const alreadyConsumed = c?.alreadyConsumed === true;
    // Clone the constructor to capture any arbitrary key/value pairs.
    const token = (c ? cloneDeep(c) : {}) as DecodedAppCheckToken;
    // Remove the AppCheckConstructor-specific property
    delete token.alreadyConsumed;
    // We don't allow overriding of these properties
    token.sub = this.appId;
    token.app_id = this.appId;
    token.aud = [this.projectNumber, this.projectId];
    token.iss = this.iss;
    // exp and iat may be overriden. Synthesize if not.
    token.exp =
      epochSeconds(c?.exp) ?? millisToSeconds(this._now()) + EPOCH_MINUTES_60;
    token.iat = epochSeconds(c?.iat) ?? token.exp - EPOCH_MINUTES_60;
    // All other arbitrary values were cloned from the AppCheckConstructor

    const r: AppCheckData = {
      appId: token.app_id,
      token,
    };

    if (alreadyConsumed) {
      r.alreadyConsumed = alreadyConsumed;
    }

    return r;
  }

  /**
   * Normalize an identity constructor into a stable, registry-safe template.
   *
   * @param ic - Identity constructor (template) with optional Firebase identity fields.
   * @returns A normalized {@link MockIdentity} template.
   *
   * @remarks
   * - Ensures `iss` is defined (falls back to manager’s {@link iss}).
   * - Ensures `uid` is defined (falls back to a generated {@link userId}).
   * - Ensures `firebase.sign_in_provider` is set (defaults to `"google.com"`).
   */
  protected staticIdentity(ic: IdentityConstructor): MockIdentity {
    const id: MockIdentity = cloneDeep(ic) as MockIdentity;
    const claims = (id as IdentityConstructor).claims;
    delete (id as IdentityConstructor).claims;
    delete (id as IdentityConstructor).signInProvider;

    id.iss = id.iss ?? this.iss;
    id.uid = ic.uid ?? userId();
    const fb: FirebaseIdentities = id.firebase ?? {};
    if (!fb.identities) {
      fb.identities = {};
    }

    id.firebase = fb;
    if (fb.sign_in_second_factor && !fb.second_factor_identifier) {
      fb.second_factor_identifier = userId();
    }
    // console.log('*** initial firebase', JSON.stringify(ic, undefined, 3));
    defaultProvider(id, ic, this.oauthIds);

    if (claims) {
      for (const [key, value] of Object.entries(claims)) {
        id[key] = value;
      }
    }

    return id;
  }
}

function defaultProvider(
  id: MockIdentity,
  ic: IdentityConstructor,
  oauth: Record<string, string>
): void {
  // If caller pre-set firebase.sign_in_provider and no override requested, respect it.
  if (ic.firebase?.sign_in_provider && ic.signInProvider == undefined) return;

  // Normalize to canonical provider IDs expected in tokens.
  const wanted = ic.signInProvider ?? 'anonymous';

  const normalize = (p: string): string => {
    switch (p) {
      case 'google':
        return 'google.com';
      case 'apple':
        return 'apple.com';
      case 'microsoft':
        return 'microsoft.com';
      case 'twitter':
        return 'twitter.com'; // not "x.com"
      case 'github':
        return 'github.com';
      case 'facebook':
        return 'facebook.com';
      case 'yahoo':
        return 'yahoo.com';
      case 'playgames':
        return 'playgames.google.com';
      case 'gamecenter':
        return 'gc.apple.com';
      case 'password':
      case 'phone':
      case 'anonymous':
      case 'custom':
        return p;
      default:
        // fall back to raw if caller passed an already-canonical ID (e.g., "oidc.foo")
        return p;
    }
  };

  const provId = normalize(wanted);
  id.firebase.sign_in_provider = provId;

  // Helper to ensure an identities bucket exists and push a unique value.
  const pushIdentity = (key: string, value: string | undefined) => {
    if (!value) return;
    const arr = (id.firebase.identities[key] ??= []);
    if (!arr.includes(value)) arr.push(value);
  };

  // For email convenience (used by "password" and as optional extra for OAuth)
  const emailOrDefault = (domain: string) =>
    id.email ?? `user-${hexId(6)}@${domain}`;

  // For OAuth providers, we need a stable provider-specific UID (opaque).
  // Use existing id.providerUid map if you have one; otherwise synthesize.
  const providerUid = (prov: string) =>
    id.firebase.identities[prov]?.[0] ?? oauth[prov] ?? providerId(wanted);

  switch (provId) {
    case 'password': {
      // identities.email -> email
      pushIdentity('email', emailOrDefault('example.com'));
      break;
    }

    case 'phone': {
      // identities.phone -> E.164 number
      const phone = id.phone_number ?? '+15551234567';
      pushIdentity('phone', phone);
      break;
    }

    case 'anonymous':
    case 'custom': {
      // Typically no identities entries for these.
      break;
    }

    default: {
      // OAuth providers (google.com, apple.com, microsoft.com, twitter.com, etc.)
      pushIdentity(provId, providerUid(provId));
      // Add the email if it exists
      if (id.email) pushIdentity('email', id.email);
      break;
    }
  }
}
